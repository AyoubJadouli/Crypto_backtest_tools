{
 "cells": [
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# AI back test methods1\n",
    "\n",
    "# --2 fonctions and dependancys\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#! python3 -m pip install --upgrade pip\n",
    "#! pip install mplfinance\n",
    "from xdata_config import *\n",
    "from functions_module import *\n",
    "import mplfinance as mpf\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import tensorflow as tf\n",
    "from keras.models import Sequential\n",
    "from keras.layers import Dense\n",
    "from keras.layers import Dropout\n",
    "from keras.constraints import MaxNorm\n",
    "from keras.optimizers import SGD\n",
    "from keras.callbacks import EarlyStopping, ModelCheckpoint\n",
    "from keras.models import Sequential\n",
    "from keras.layers import Dense \n",
    "from keras.models import load_model\n",
    "from datetime import datetime"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import requests\n",
    "\n",
    "url = 'https://api.binance.com/api/v3/ticker/price'\n",
    "\n",
    "response = requests.get(url)\n",
    "tickers = response.json()\n",
    "ticker_list=[]\n",
    "for ticker in tickers:\n",
    "    ticker_list.append((ticker['symbol']))\n"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# --1 Config"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# ai_options\n",
    "Normalization_File= \"False\"\n",
    "Model_FileName= \"/UltimeTradingBot/Data/BUY_FIX/tp80_w7_max3min_Model_true_win_model_Re4.h5\"\n",
    "WINDOW_SIZE= 7\n",
    "PRESSISION=0.0\n",
    "PERIODE_START=\"2022-04-21 00:00:00\"\n",
    "PERIODE_END=\"2022-05-11 00:00:00\"\n",
    "\n",
    "# start_period = datetime.strptime(PERIODE_START, '%d-%m-%Y %H:%M:%S')\n",
    "# end_period = datetime.strptime(PERIODE_END, '%d-%m-%Y %H:%M:%S')\n",
    "start_period = pd.Timestamp(PERIODE_START)\n",
    "end_period = pd.Timestamp(PERIODE_END)\n",
    "\n",
    "\n",
    "#trading_options:\n",
    "TAKE_PROFIT= 0.4  \n",
    "STOP_LOSS=  0.8 \n",
    "MAX_HOLDING_TIME= 16\n",
    "\n",
    "USE_TRAILING_STOP_LOSS: False\n",
    "TRAILING_STOP_LOSS= .002     \n",
    "TRAILING_TAKE_PROFIT= .002  \n",
    "\n",
    "PAIR_WITH= \"USDT\"\n",
    "TRADE_TOTAL= 100 \n",
    "TRADE_SLOTS= 5\n",
    "\n",
    "TRADING_FEE= 0.1\n",
    "  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import pandas as pd\n",
    "import mplfinance as mpf\n",
    "\n",
    "# Import necessary libraries\n",
    "import pandas as pd\n",
    "import mplfinance as mpf\n",
    "\n",
    "def plot_ohlcv(df,title, start_date, end_date):\n",
    "    \"\"\"\n",
    "    Plots OHLCV data using mplfinance library.\n",
    "\n",
    "    Args:\n",
    "    df (pd.DataFrame): Dataframe containing OHLCV data with columns ['date', 'open', 'high', 'low', 'close', 'volume'].\n",
    "    start_date (str): Start date of the plot in the format 'YYYY-MM-DD'.\n",
    "    end_date (str): End date of the plot in the format 'YYYY-MM-DD'.\n",
    "    \"\"\"\n",
    "\n",
    "    # # Ensure the index is of type datetime and sorted\n",
    "    # df['date'] = pd.to_datetime(df['date'])\n",
    "    # df = df.set_index('date')\n",
    "    # df = df.sort_index()\n",
    "\n",
    "    # Filter the data between start_date and end_date\n",
    "    mask = (df.index >= start_date) & (df.index <= end_date)\n",
    "    filtered_df = df.loc[mask]\n",
    "\n",
    "    # Set the plot size to full width\n",
    "    fig_width = 25\n",
    "    fig_height = 9\n",
    "\n",
    "    # Plot the OHLCV chart\n",
    "    mpf.plot(filtered_df, type='candle', style='charles', volume=True, title=title, ylabel='Price', ylabel_lower='Volume', figratio=(fig_width, fig_height),  tight_layout=True)\n",
    "\n",
    "\n",
    "best_testing_pair=\"LTC/USDT\"\n",
    "plot_ohlcv(df_list1h[best_testing_pair],best_testing_pair, start_date=PERIODE_START, end_date=PERIODE_END)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def find_worst_period(df, window):\n",
    "    \"\"\"\n",
    "    Find the worst period with the largest price drop in the given OHLCV DataFrame.\n",
    "\n",
    "    Args:\n",
    "    df (pd.DataFrame): Dataframe containing OHLCV data with columns ['date', 'open', 'high', 'low', 'close', 'volume'].\n",
    "    window (int): Window size for calculating the largest price drop.\n",
    "\n",
    "    Returns:\n",
    "    (pd.Timestamp, pd.Timestamp): Start and end date of the worst period.\n",
    "    \"\"\"\n",
    "\n",
    "\n",
    "    # Calculate rolling minimum close prices\n",
    "    min_close = df['close'].rolling(window=window).min()\n",
    "\n",
    "    # Find the largest price drop within the specified window\n",
    "    largest_drop = (df['close'] / min_close.shift(1) - 1).idxmin()\n",
    "\n",
    "    # Calculate start and end dates of the worst period\n",
    "    start_date = largest_drop - pd.Timedelta(days=window-1)\n",
    "    end_date = largest_drop\n",
    "\n",
    "    return start_date, end_date\n",
    "\n",
    "WORST_BTC_PERIOD=find_worst_period(df_list1h[best_testing_pair], window=10)\n",
    "plot_ohlcv(df_list1h[best_testing_pair],best_testing_pair, start_date=WORST_BTC_PERIOD[0], end_date=WORST_BTC_PERIOD[1])\n"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# --3 Importing DATA"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from datetime import date\n",
    "#TICKERS = \"../Binance-Fast-Trade-Bot/volatile_volume_\" + str(date.today()) + \".txt\"\n",
    "TICKERS = \"/UltimeTradingBot/Binance-Fast-Trade-Bot/halal_coins.txt\"\n",
    "VOLATILE_COINS=[line.strip() for line in open(TICKERS)]\n",
    "PAIR_WITH=\"USDT\"\n",
    "VOLATILE_USDT_PAIRS=[coin+\"/USDT\" for coin in VOLATILE_COINS]\n",
    "VOLATILE_BUSD_PAIRS=[coin+\"/BUSD\" for coin in VOLATILE_COINS]\n",
    "for pair in VOLATILE_BUSD_PAIRS:\n",
    "    if pair.replace('/' ,'') not  in ticker_list:\n",
    "        print(pair)\n",
    "        VOLATILE_BUSD_PAIRS.remove(pair)\n",
    "\n",
    "for pair in VOLATILE_USDT_PAIRS:\n",
    "    if pair.replace('/', '') not in ticker_list:\n",
    "        print(pair)\n",
    "        VOLATILE_USDT_PAIRS.remove(pair)\n",
    "\n",
    "content = os.listdir('database/DataBackTest/1m')\n",
    "for pair in VOLATILE_USDT_PAIRS:\n",
    "    if pair.replace('/', '-')+'.csv' not in content:\n",
    "        print(pair)\n",
    "        VOLATILE_USDT_PAIRS.remove(pair)\n",
    "for pair in VOLATILE_BUSD_PAIRS:\n",
    "    if pair.replace('/', '-')+'.csv' not in content:\n",
    "        print(pair)\n",
    "        VOLATILE_BUSD_PAIRS.remove(pair)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# coins_to_download=''\n",
    "# for coin in LISTCOIN:\n",
    "#     coins_to_download=coins_to_download+\" \"+coin\n",
    "# os.system(f\"node database/dd_for_backtest.js {coins_to_download} {PAIR_WITH}\")#node database/ddargs.js ORN BUSD"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "pair_list = VOLATILE_USDT_PAIRS\n",
    "#tf = '1m'\n",
    "oldest_pair = \"BTC/USDT\"\n",
    "if oldest_pair not in pair_list: pair_list.append(oldest_pair)\n",
    "df_list1m = {}\n",
    "df_list1d = {}\n",
    "df_list1h = {}\n",
    "df_list5m = {}\n",
    "df_list15m = {}\n",
    "\n",
    "\n",
    "for pair in pair_list:\n",
    "    df = get_backtest_historical(ccxt.binance(), pair, '1m', path=\"./database/\")\n",
    "    df_list1m[pair] = df.loc[:]\n",
    "\n",
    "for pair in pair_list:\n",
    "    df = get_backtest_historical(ccxt.binance(), pair, '1d', path=\"./database/\")\n",
    "    df_list1d[pair] = df.loc[:]\n",
    "\n",
    "for pair in pair_list:\n",
    "    df = get_backtest_historical(ccxt.binance(), pair, '1h', path=\"./database/\")\n",
    "    df_list1h[pair] = df.loc[:]\n",
    "\n",
    "for pair in pair_list:\n",
    "    df = get_backtest_historical(ccxt.binance(), pair, '5m', path=\"./database/\")\n",
    "    df_list5m[pair] = df.loc[:]\n",
    "\n",
    "for pair in pair_list:\n",
    "    df = get_backtest_historical(\n",
    "        ccxt.binance(), pair, '15m', path=\"./database/\")\n",
    "    df_list15m[pair] = df.loc[:]\n",
    "del(df)\n",
    "df_list = df_list1m\n",
    "prerr(\"Data load 100% use df_list1d[\\\"BTC/USDT\\\"] for exemple to access\")\n",
    "\n"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# --3 Decalring Tables"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Functions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "\n",
    "def mini_expand5(pair=\"GMT/USDT\", i=0, j=10000, window=2, metadata=MetaData,\n",
    "                 high_weight=1, BUY_PCT=BUY_PCT, SELL_PCT=SELL_PCT,\n",
    "                 buy_function=buy_alwase):\n",
    "    start_index=i\n",
    "    end_index=j\n",
    "    window_size=window\n",
    "    buy_fn=buy_function\n",
    "    \"\"\"\n",
    "    This function takes in several parameters to calculate technical indicators and returns a merged dataframe.\n",
    "    \n",
    "    :param pair: str, default \"GMT/USDT\"\n",
    "        The trading pair to analyze.\n",
    "        \n",
    "    :param start_index: int, default 0\n",
    "        The start index for selecting data.\n",
    "        \n",
    "    :param end_index: int, default 10000\n",
    "        The end index for selecting data.\n",
    "    \n",
    "    :param window_size: int, default 2\n",
    "        The window size to use for analyzing the data.\n",
    "    \n",
    "    :param metadata: MetaData\n",
    "        The metadata to use for analyzing the data.\n",
    "    \n",
    "    :param high_weight: int, default 1\n",
    "        The weight to use for calculating the high.\n",
    "    \n",
    "    :param BUY_PCT: float, default BUY_PCT\n",
    "        The buy pct to use for analyzing the data.\n",
    "    \n",
    "    :param SELL_PCT: float, default SELL_PCT\n",
    "        The sell pct to use for analyzing the data.\n",
    "    \n",
    "    :param buy_fn: function, default buy_min_up\n",
    "        The buy function to use for analyzing the data.\n",
    "    \n",
    "    :return: pd.DataFrame\n",
    "        A merged dataframe containing the calculated technical indicators.\n",
    "    \"\"\"\n",
    "    print(f\"mini_expand : {pair}\")\n",
    "    # Select data\n",
    "    pair_df = df_list1m[pair].iloc[start_index:end_index]\n",
    "    btc_df = df_list1m[\"BTC/USDT\"].loc[(pair_df.index[0] - pd.DateOffset(days=window_size+1)).round(freq='1 min'):pair_df.index[-1]+pd.Timedelta(f\"{window_size} day\")]\n",
    "    # Calculate technical indicators\n",
    "    pair_full = full_expand(pair_df, df_list5m[pair], df_list15m[pair], df_list1h[pair], df_list1d[pair], window_size)\n",
    "    btc_full = full_expand(btc_df, df_list5m[\"BTC/USDT\"], df_list15m[\"BTC/USDT\"], df_list1h[\"BTC/USDT\"], df_list1d[\"BTC/USDT\"], window_size)   \n",
    "    btc_full = btc_full.add_prefix(\"BTC_\")\n",
    "    merged = pd.merge(pair_full, btc_full, left_index=True, right_index=True)\n",
    "    day_expand(merged)\n",
    "    Meta_expand(merged, metadata, pair)\n",
    "    merged = buy_fn(merged, BUY_PCT=BUY_PCT, SELL_PCT=SELL_PCT, window=MAX_FORCAST_SIZE)\n",
    "    merged[\"high\"] = (merged[\"open\"] + high_weight * merged[\"high\"] + merged[\"low\"] + merged[\"close\"]) / (3 + high_weight)\n",
    "    merged[\"BTC_high\"] = (merged[\"BTC_open\"] + high_weight * merged[\"BTC_high\"] + merged[\"BTC_low\"] + merged[\"BTC_close\"]) / (3 + high_weight)\n",
    "    merged.rename(columns={\"high\":\"price\"},inplace=True)\n",
    "    merged.rename(columns={\"BTC_high\":\"BTC_price\"},inplace=True)\n",
    "    merged = merged.drop(columns=[\"BTC_open\",\"BTC_low\",\"BTC_close\",\"open\",\"low\",\"close\"])\n",
    "    open_high_low_close_cols = merged.columns.str.contains(\"open|high|low|close\")\n",
    "    # merged.loc[:, open_high_low_close_cols & merged.columns.str.contains(\"BTC\")] = (\n",
    "    #     (merged[\"BTC_price\"] - merged.loc[:, open_high_low_close_cols & merged.columns.str.contains(\"BTC\")]) / merged[\"BTC_price\"]\n",
    "    # )\n",
    "    # merged.loc[:, open_high_low_close_cols & ~merged.columns.str.contains(\"BTC\")] = (\n",
    "    #     (merged[\"price\"] - merged.loc[:, open_high_low_close_cols & ~merged.columns.str.contains(\"BTC\")]) / merged[\"price\"]\n",
    "    # )\n",
    "    for key in merged.keys():\n",
    "        if key.find(\"BTC\")!=-1 and (key.find(\"open\")!=-1 or\n",
    "    key.find(\"high\")!=-1 or key.find(\"low\")!=-1 or key.find(\"close\")!=-1):\n",
    "            merged[key]=(merged[\"BTC_price\"]-merged[key])/merged[\"BTC_price\"]\n",
    "        if key.find(\"BTC\")==-1 and (key.find(\"open\")!=-1 or\n",
    "    key.find(\"high\")!=-1 or key.find(\"low\")!=-1 or key.find(\"close\")!=-1):\n",
    "            merged[key]=(merged[\"price\"]-merged[key])/merged[\"price\"]\n",
    "\n",
    "    merged=merged.dropna()\n",
    "    print(f'######################  mini_expand5 {pair} - shape {merged.shape}  buy mean : {hp(merged.buy.mean())} ############################')\n",
    "    return merged\n",
    "\n",
    "\n",
    "def create_portfolio_dataframe(num_slots,init_quantity=500, base_currency='usdt'):\n",
    "    # create an empty DataFrame with the columns we need\n",
    "    columns = ['date', f'reserve_{base_currency}',f'total_{base_currency}']\n",
    "    for i in range(num_slots):\n",
    "        columns += [f'slot{i+1}_symbol', f'slot{i+1}_volume', f'slot{i+1}_original_price_{base_currency}', f'slot{i+1}_current_total_{base_currency}']\n",
    "    df = pd.DataFrame(columns=columns)\n",
    "    \n",
    "    # create some sample data\n",
    "    for date in pd.date_range(PERIODE_START, periods=1):\n",
    "        data = {'date': date, f'total_{base_currency}': init_quantity}\n",
    "        # for i in range(num_slots):\n",
    "        #     symbol = f'coin{i+1}'\n",
    "        #     volume = (i+1) * 100\n",
    "        #     bought_currency = base_currency.upper()\n",
    "        #     bought_value = (i+1) * 500\n",
    "        #     current_price = (i+1) * 1.5\n",
    "        #     current_total = volume * current_price\n",
    "        #     data.update({\n",
    "        #         f'slot{i+1}_symbol': symbol,\n",
    "        #         f'slot{i+1}_volume': volume,\n",
    "        #         f'slot{i+1}_original_price_{base_currency}': bought_value,\n",
    "        #         f'slot{i+1}_current_total_{base_currency}': current_total,\n",
    "        #     })\n",
    "        #     data[f'total_{base_currency}'] += current_total\n",
    "        df = df.append(data, ignore_index=True)\n",
    "    \n",
    "    # set the date column as the index of the DataFrame\n",
    "    df.set_index('date', inplace=True)\n",
    "    df.iloc[:,0]=np.float64(init_quantity)\n",
    "    return df.iloc[0:1]\n",
    "\n",
    "\n",
    "\n",
    "def generate_signals(ALLTOP20VOLUMES, df_list1m, WINDOW_SIZE, MetaData, TAKE_PROFIT, STOP_LOSS, backtest_model):\n",
    "    SIGNAL_DF = pd.DataFrame(columns=['coin', 'time', 'price', 'note'])\n",
    "    for day, TOPLIST in ALLTOP20VOLUMES.items():\n",
    "        for coin in TOPLIST:\n",
    "            try:\n",
    "                print(f\">>>>>>>>>>> working on {coin} at: {day} :\")\n",
    "                loc_start = df_list1m[coin].index.get_loc(day)\n",
    "                loc_end = df_list1m[coin].index.get_loc(day+pd.Timedelta('1 day'))\n",
    "                gc.collect()\n",
    "                df = mini_expand5(pair=coin, i=loc_start, j=loc_end, window=WINDOW_SIZE, metadata=MetaData, BUY_PCT=TAKE_PROFIT, SELL_PCT=STOP_LOSS, buy_function=buy_alwase)\n",
    "                dt = df.iloc[:,:-1].to_numpy(dtype=np.float32)\n",
    "                predictions_note = backtest_model.predict(dt)\n",
    "                predictions_round = predictions_note.round()\n",
    "                dico_signal = {\"coin\":coin, \"time\":df[predictions_round==1].index.values, \"price\":df[predictions_round==1][\"price\"].values, \"note\":predictions_note[predictions_round==1]}\n",
    "                df_signal_coin = pd.DataFrame(dico_signal)\n",
    "                SIGNAL_DF = pd.concat([SIGNAL_DF, df_signal_coin])\n",
    "            except:\n",
    "                print(f\"error at {day} in {coin}\")\n",
    "    return SIGNAL_DF\n",
    "\n",
    "\n",
    "def get_top_volumes(start_period,end_period):\n",
    "    ALLTOP20VOLUMES={}\n",
    "    for day in df_list1d[\"BTC/USDT\"].index:\n",
    "        if start_period<= day <= end_period:\n",
    "            Top20vol={}\n",
    "            for p,df in df_list1d.items():\n",
    "                if p not in [\"EUR/USDT\",\"EUR/BUSD\",\"BTC/USDT\",\"BTC/BUSD\"]:\n",
    "                    try:Top20vol.update({p:(df.loc[day].volume*df.loc[day].close)})\n",
    "                    except Exception as e :print(f'Time Error wile working on {p}: {e}')\n",
    "                    #print (Top20vol)\n",
    "            ALLTOP20VOLUMES.update({day:sorted(Top20vol, key=Top20vol.get, reverse=True)[:20]})\n",
    "    return ALLTOP20VOLUMES\n",
    "\n",
    "def is_coin_in_portfolio(symbol,instant,PORTFOLIO):\n",
    "    for i in range(1,TRADE_SLOTS+1):\n",
    "        try:\n",
    "            if (PORTFOLIO[f\"slot{i}_symbol\"].loc[instant]==symbol):\n",
    "                return i\n",
    "        except Exception as e:\n",
    "            print(f\"error :{e}\")\n",
    "    return False"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "PORTFOLIO=create_portfolio_dataframe(TRADE_SLOTS,init_quantity=500, base_currency=PAIR_WITH) #pair with plus slots plus total\n",
    "ORDER_HISTORY= pd.DataFrame(columns= ['Order ID', 'Pair', 'Side', 'Price', 'Quantity', 'Executed', 'Time', 'Status'])\n",
    "#SIGNAL_DF=pd.DataFrame(columns= ['coin', 'time',\"price\",'note'])\n",
    "ALLTOP20VOLUMES=get_top_volumes(start_period,end_period)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ALLTOP20VOLUMES[pd.Timestamp(\"2022-05-09\")]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "backtest_model=load_model(\"/UltimeTradingBot/Data/BUY_TEST/tp70_w7_max2min_Model_VeryDeep.h5\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 62,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 TRX/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 0s 7ms/step\n",
      ">>>>>>>>>>> working on APE/USDT at: 2022-05-08 00:00:00 :\n",
      "mini_expand : APE/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 APE/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 0s 7ms/step\n",
      ">>>>>>>>>>> working on SOL/USDT at: 2022-05-08 00:00:00 :\n",
      "mini_expand : SOL/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 SOL/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 0s 7ms/step\n",
      ">>>>>>>>>>> working on GAL/USDT at: 2022-05-08 00:00:00 :\n",
      "mini_expand : GAL/USDT\n",
      "Precent Mean: nan%\n",
      "######################  mini_expand5 GAL/USDT - shape (0, 287)  buy mean : nan ############################\n",
      "error at 2022-05-08 00:00:00 in GAL/USDT\n",
      ">>>>>>>>>>> working on XRP/USDT at: 2022-05-08 00:00:00 :\n",
      "mini_expand : XRP/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 XRP/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 0s 7ms/step\n",
      ">>>>>>>>>>> working on NEAR/USDT at: 2022-05-08 00:00:00 :\n",
      "mini_expand : NEAR/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 NEAR/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 0s 6ms/step\n",
      ">>>>>>>>>>> working on AVAX/USDT at: 2022-05-08 00:00:00 :\n",
      "mini_expand : AVAX/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 AVAX/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 20ms/step\n",
      ">>>>>>>>>>> working on SHIB/USDT at: 2022-05-08 00:00:00 :\n",
      "mini_expand : SHIB/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 SHIB/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 17ms/step\n",
      ">>>>>>>>>>> working on ADA/USDT at: 2022-05-08 00:00:00 :\n",
      "mini_expand : ADA/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 ADA/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 21ms/step\n",
      ">>>>>>>>>>> working on ALGO/USDT at: 2022-05-08 00:00:00 :\n",
      "mini_expand : ALGO/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 ALGO/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 0s 7ms/step\n",
      ">>>>>>>>>>> working on DOGE/USDT at: 2022-05-08 00:00:00 :\n",
      "mini_expand : DOGE/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 DOGE/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 0s 7ms/step\n",
      ">>>>>>>>>>> working on DOT/USDT at: 2022-05-08 00:00:00 :\n",
      "mini_expand : DOT/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 DOT/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 22ms/step\n",
      ">>>>>>>>>>> working on ZIL/USDT at: 2022-05-08 00:00:00 :\n",
      "mini_expand : ZIL/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 ZIL/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 18ms/step\n",
      ">>>>>>>>>>> working on AXS/USDT at: 2022-05-08 00:00:00 :\n",
      "mini_expand : AXS/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 AXS/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 16ms/step\n",
      ">>>>>>>>>>> working on ENS/USDT at: 2022-05-08 00:00:00 :\n",
      "mini_expand : ENS/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 ENS/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 19ms/step\n",
      ">>>>>>>>>>> working on GALA/USDT at: 2022-05-08 00:00:00 :\n",
      "mini_expand : GALA/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 GALA/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 15ms/step\n",
      ">>>>>>>>>>> working on ETH/USDT at: 2022-05-09 00:00:00 :\n",
      "mini_expand : ETH/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 ETH/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 11ms/step\n",
      ">>>>>>>>>>> working on UST/USDT at: 2022-05-09 00:00:00 :\n",
      "mini_expand : UST/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 UST/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 0s 7ms/step\n",
      ">>>>>>>>>>> working on LUNA/USDT at: 2022-05-09 00:00:00 :\n",
      "mini_expand : LUNA/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 LUNA/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 0s 6ms/step\n",
      ">>>>>>>>>>> working on GMT/USDT at: 2022-05-09 00:00:00 :\n",
      "mini_expand : GMT/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 GMT/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 0s 7ms/step\n",
      ">>>>>>>>>>> working on TRX/USDT at: 2022-05-09 00:00:00 :\n",
      "mini_expand : TRX/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 TRX/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 20ms/step\n",
      ">>>>>>>>>>> working on APE/USDT at: 2022-05-09 00:00:00 :\n",
      "mini_expand : APE/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 APE/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 19ms/step\n",
      ">>>>>>>>>>> working on XRP/USDT at: 2022-05-09 00:00:00 :\n",
      "mini_expand : XRP/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 XRP/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 0s 7ms/step\n",
      ">>>>>>>>>>> working on SOL/USDT at: 2022-05-09 00:00:00 :\n",
      "mini_expand : SOL/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 SOL/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 0s 7ms/step\n",
      ">>>>>>>>>>> working on SHIB/USDT at: 2022-05-09 00:00:00 :\n",
      "mini_expand : SHIB/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 SHIB/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 20ms/step\n",
      ">>>>>>>>>>> working on NEAR/USDT at: 2022-05-09 00:00:00 :\n",
      "mini_expand : NEAR/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 NEAR/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 17ms/step\n",
      ">>>>>>>>>>> working on ADA/USDT at: 2022-05-09 00:00:00 :\n",
      "mini_expand : ADA/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 ADA/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 15ms/step\n",
      ">>>>>>>>>>> working on AVAX/USDT at: 2022-05-09 00:00:00 :\n",
      "mini_expand : AVAX/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 AVAX/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 25ms/step\n",
      ">>>>>>>>>>> working on GAL/USDT at: 2022-05-09 00:00:00 :\n",
      "mini_expand : GAL/USDT\n",
      "Precent Mean: nan%\n",
      "######################  mini_expand5 GAL/USDT - shape (0, 287)  buy mean : nan ############################\n",
      "error at 2022-05-09 00:00:00 in GAL/USDT\n",
      ">>>>>>>>>>> working on DOGE/USDT at: 2022-05-09 00:00:00 :\n",
      "mini_expand : DOGE/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 DOGE/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 0s 7ms/step\n",
      ">>>>>>>>>>> working on DOT/USDT at: 2022-05-09 00:00:00 :\n",
      "mini_expand : DOT/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 DOT/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 11ms/step\n",
      ">>>>>>>>>>> working on WAVES/USDT at: 2022-05-09 00:00:00 :\n",
      "mini_expand : WAVES/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 WAVES/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 17ms/step\n",
      ">>>>>>>>>>> working on ZIL/USDT at: 2022-05-09 00:00:00 :\n",
      "mini_expand : ZIL/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 ZIL/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 19ms/step\n",
      ">>>>>>>>>>> working on AXS/USDT at: 2022-05-09 00:00:00 :\n",
      "mini_expand : AXS/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 AXS/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 0s 7ms/step\n",
      ">>>>>>>>>>> working on GALA/USDT at: 2022-05-09 00:00:00 :\n",
      "mini_expand : GALA/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 GALA/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 0s 7ms/step\n",
      ">>>>>>>>>>> working on ALGO/USDT at: 2022-05-09 00:00:00 :\n",
      "mini_expand : ALGO/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 ALGO/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 13ms/step\n",
      ">>>>>>>>>>> working on ETH/USDT at: 2022-05-10 00:00:00 :\n",
      "mini_expand : ETH/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 ETH/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 21ms/step\n",
      ">>>>>>>>>>> working on LUNA/USDT at: 2022-05-10 00:00:00 :\n",
      "mini_expand : LUNA/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 LUNA/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 17ms/step\n",
      ">>>>>>>>>>> working on UST/USDT at: 2022-05-10 00:00:00 :\n",
      "mini_expand : UST/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 UST/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 17ms/step\n",
      ">>>>>>>>>>> working on GMT/USDT at: 2022-05-10 00:00:00 :\n",
      "mini_expand : GMT/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 GMT/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 0s 6ms/step\n",
      ">>>>>>>>>>> working on APE/USDT at: 2022-05-10 00:00:00 :\n",
      "mini_expand : APE/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 APE/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 0s 8ms/step\n",
      ">>>>>>>>>>> working on SOL/USDT at: 2022-05-10 00:00:00 :\n",
      "mini_expand : SOL/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 SOL/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 0s 6ms/step\n",
      ">>>>>>>>>>> working on XRP/USDT at: 2022-05-10 00:00:00 :\n",
      "mini_expand : XRP/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 XRP/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 20ms/step\n",
      ">>>>>>>>>>> working on SHIB/USDT at: 2022-05-10 00:00:00 :\n",
      "mini_expand : SHIB/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 SHIB/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 21ms/step\n",
      ">>>>>>>>>>> working on TRX/USDT at: 2022-05-10 00:00:00 :\n",
      "mini_expand : TRX/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 TRX/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 12ms/step\n",
      ">>>>>>>>>>> working on AVAX/USDT at: 2022-05-10 00:00:00 :\n",
      "mini_expand : AVAX/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 AVAX/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 20ms/step\n",
      ">>>>>>>>>>> working on NEAR/USDT at: 2022-05-10 00:00:00 :\n",
      "mini_expand : NEAR/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 NEAR/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 0s 6ms/step\n",
      ">>>>>>>>>>> working on ADA/USDT at: 2022-05-10 00:00:00 :\n",
      "mini_expand : ADA/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 ADA/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 0s 6ms/step\n",
      ">>>>>>>>>>> working on DOT/USDT at: 2022-05-10 00:00:00 :\n",
      "mini_expand : DOT/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 DOT/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 12ms/step\n",
      ">>>>>>>>>>> working on DOGE/USDT at: 2022-05-10 00:00:00 :\n",
      "mini_expand : DOGE/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 DOGE/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 12ms/step\n",
      ">>>>>>>>>>> working on GAL/USDT at: 2022-05-10 00:00:00 :\n",
      "mini_expand : GAL/USDT\n",
      "Precent Mean: nan%\n",
      "######################  mini_expand5 GAL/USDT - shape (0, 287)  buy mean : nan ############################\n",
      "error at 2022-05-10 00:00:00 in GAL/USDT\n",
      ">>>>>>>>>>> working on ZIL/USDT at: 2022-05-10 00:00:00 :\n",
      "mini_expand : ZIL/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 ZIL/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 13ms/step\n",
      ">>>>>>>>>>> working on GALA/USDT at: 2022-05-10 00:00:00 :\n",
      "mini_expand : GALA/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 GALA/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 14ms/step\n",
      ">>>>>>>>>>> working on WAVES/USDT at: 2022-05-10 00:00:00 :\n",
      "mini_expand : WAVES/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 WAVES/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 16ms/step\n",
      ">>>>>>>>>>> working on LTC/USDT at: 2022-05-10 00:00:00 :\n",
      "mini_expand : LTC/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 LTC/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 20ms/step\n",
      ">>>>>>>>>>> working on ALGO/USDT at: 2022-05-10 00:00:00 :\n",
      "mini_expand : ALGO/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 ALGO/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 18ms/step\n",
      ">>>>>>>>>>> working on ETH/USDT at: 2022-05-11 00:00:00 :\n",
      "mini_expand : ETH/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 ETH/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 14ms/step\n",
      ">>>>>>>>>>> working on UST/USDT at: 2022-05-11 00:00:00 :\n",
      "mini_expand : UST/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 UST/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 17ms/step\n",
      ">>>>>>>>>>> working on LUNA/USDT at: 2022-05-11 00:00:00 :\n",
      "mini_expand : LUNA/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 LUNA/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 0s 6ms/step\n",
      ">>>>>>>>>>> working on GMT/USDT at: 2022-05-11 00:00:00 :\n",
      "mini_expand : GMT/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 GMT/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 0s 5ms/step\n",
      ">>>>>>>>>>> working on XRP/USDT at: 2022-05-11 00:00:00 :\n",
      "mini_expand : XRP/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 XRP/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 0s 7ms/step\n",
      ">>>>>>>>>>> working on TRX/USDT at: 2022-05-11 00:00:00 :\n",
      "mini_expand : TRX/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 TRX/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 0s 7ms/step\n",
      ">>>>>>>>>>> working on SOL/USDT at: 2022-05-11 00:00:00 :\n",
      "mini_expand : SOL/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 SOL/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 19ms/step\n",
      ">>>>>>>>>>> working on APE/USDT at: 2022-05-11 00:00:00 :\n",
      "mini_expand : APE/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 APE/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 18ms/step\n",
      ">>>>>>>>>>> working on NEAR/USDT at: 2022-05-11 00:00:00 :\n",
      "mini_expand : NEAR/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 NEAR/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 0s 6ms/step\n",
      ">>>>>>>>>>> working on AVAX/USDT at: 2022-05-11 00:00:00 :\n",
      "mini_expand : AVAX/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 AVAX/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 0s 7ms/step\n",
      ">>>>>>>>>>> working on DOGE/USDT at: 2022-05-11 00:00:00 :\n",
      "mini_expand : DOGE/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 DOGE/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 13ms/step\n",
      ">>>>>>>>>>> working on SHIB/USDT at: 2022-05-11 00:00:00 :\n",
      "mini_expand : SHIB/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 SHIB/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 17ms/step\n",
      ">>>>>>>>>>> working on ADA/USDT at: 2022-05-11 00:00:00 :\n",
      "mini_expand : ADA/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 ADA/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 22ms/step\n",
      ">>>>>>>>>>> working on DOT/USDT at: 2022-05-11 00:00:00 :\n",
      "mini_expand : DOT/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 DOT/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 7ms/step\n",
      ">>>>>>>>>>> working on GAL/USDT at: 2022-05-11 00:00:00 :\n",
      "mini_expand : GAL/USDT\n",
      "Precent Mean: nan%\n",
      "######################  mini_expand5 GAL/USDT - shape (0, 287)  buy mean : nan ############################\n",
      "error at 2022-05-11 00:00:00 in GAL/USDT\n",
      ">>>>>>>>>>> working on ZIL/USDT at: 2022-05-11 00:00:00 :\n",
      "mini_expand : ZIL/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 ZIL/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 22ms/step\n",
      ">>>>>>>>>>> working on GALA/USDT at: 2022-05-11 00:00:00 :\n",
      "mini_expand : GALA/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 GALA/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 0s 6ms/step\n",
      ">>>>>>>>>>> working on LTC/USDT at: 2022-05-11 00:00:00 :\n",
      "mini_expand : LTC/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 LTC/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 0s 6ms/step\n",
      ">>>>>>>>>>> working on AXS/USDT at: 2022-05-11 00:00:00 :\n",
      "mini_expand : AXS/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 AXS/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 20ms/step\n",
      ">>>>>>>>>>> working on ALGO/USDT at: 2022-05-11 00:00:00 :\n",
      "mini_expand : ALGO/USDT\n",
      "Precent Mean: 100.000%\n",
      "######################  mini_expand5 ALGO/USDT - shape (1433, 287)  buy mean : 100.0 ############################\n",
      "45/45 [==============================] - 1s 20ms/step\n"
     ]
    }
   ],
   "source": [
    "SIGNAL_DF = generate_signals(ALLTOP20VOLUMES, df_list1m, WINDOW_SIZE, MetaData, TAKE_PROFIT, STOP_LOSS, backtest_model)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 66,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>coin</th>\n",
       "      <th>time</th>\n",
       "      <th>price</th>\n",
       "      <th>note</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>ETH/USDT</td>\n",
       "      <td>2022-04-21 01:25:00</td>\n",
       "      <td>3091.572500</td>\n",
       "      <td>0.501955</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>77</th>\n",
       "      <td>GMT/USDT</td>\n",
       "      <td>2022-04-21 01:25:00</td>\n",
       "      <td>3.387835</td>\n",
       "      <td>0.600416</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>78</th>\n",
       "      <td>APE/USDT</td>\n",
       "      <td>2022-04-21 01:25:00</td>\n",
       "      <td>16.186850</td>\n",
       "      <td>0.534667</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>78</th>\n",
       "      <td>JASMY/USDT</td>\n",
       "      <td>2022-04-21 01:25:00</td>\n",
       "      <td>0.026625</td>\n",
       "      <td>0.679328</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>78</th>\n",
       "      <td>ZIL/USDT</td>\n",
       "      <td>2022-04-21 01:25:00</td>\n",
       "      <td>0.130940</td>\n",
       "      <td>0.699817</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>78</th>\n",
       "      <td>ZRX/USDT</td>\n",
       "      <td>2022-04-21 01:25:00</td>\n",
       "      <td>1.057650</td>\n",
       "      <td>0.797055</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>45</th>\n",
       "      <td>XMR/USDT</td>\n",
       "      <td>2022-04-21 01:25:00</td>\n",
       "      <td>270.200000</td>\n",
       "      <td>0.535075</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "          coin                time        price      note\n",
       "0     ETH/USDT 2022-04-21 01:25:00  3091.572500  0.501955\n",
       "77    GMT/USDT 2022-04-21 01:25:00     3.387835  0.600416\n",
       "78    APE/USDT 2022-04-21 01:25:00    16.186850  0.534667\n",
       "78  JASMY/USDT 2022-04-21 01:25:00     0.026625  0.679328\n",
       "78    ZIL/USDT 2022-04-21 01:25:00     0.130940  0.699817\n",
       "78    ZRX/USDT 2022-04-21 01:25:00     1.057650  0.797055\n",
       "45    XMR/USDT 2022-04-21 01:25:00   270.200000  0.535075"
      ]
     },
     "execution_count": 66,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "SIGNAL_DF[SIGNAL_DF.time==\"2022-04-21 01:25:00\"]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "SIGNAL_DF=pd.DataFrame(columns= ['coin', 'time',\"price\",'note'])\n",
    "for day,TOPLIST in ALLTOP20VOLUMES.items():\n",
    "    for coin in TOPLIST:\n",
    "        try:\n",
    "            print(f\">>>>>>>>>>> working on {coin} at: {day} :\")\n",
    "            loc_start=df_list1m[coin].index.get_loc(day)\n",
    "            loc_end=df_list1m[coin].index.get_loc(day+pd.Timedelta('1 day'))\n",
    "            gc.collect()\n",
    "            df=mini_expand4(pair=coin,i=loc_start,j=loc_end,window=WINDOW_SIZE,metadata=MetaData,BUY_PCT=TAKE_PROFIT,SELL_PCT=STOP_LOSS,buy_function=buy_alwase)\n",
    "            dt=df.iloc[:,:-1].to_numpy(dtype=np.float32)\n",
    "            predictions_note=backtest_model.predict(dt)\n",
    "            predictions_round=predictions_note.round()\n",
    "            dico_signal={\"coin\":coin,\"time\":df[predictions_round==1].index.values,\"price\":df[predictions_round==1][\"price\"].values,\"note\":predictions_note[predictions_round==1]}\n",
    "            df_signal_coin = pd.DataFrame(dico_signal)\n",
    "            SIGNAL_DF=pd.concat([SIGNAL_DF,df_signal_coin])\n",
    "        except:\n",
    "            print(f\"error at {day} in {coin}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "SIGNAL_DF = pd.DataFrame(columns=['coin', 'time', 'price', 'note'])\n",
    "\n",
    "for day, TOPLIST in ALLTOP20VOLUMES.items():\n",
    "    for coin in TOPLIST:\n",
    "        try:\n",
    "            print(f\">>>>>>>>>>> working on {coin} at: {day} :\")\n",
    "            loc_start = df_list1m[coin].index.get_loc(day)\n",
    "            loc_end = df_list1m[coin].index.get_loc(day + pd.Timedelta('1 day'))\n",
    "            gc.collect()\n",
    "\n",
    "            # Get the required columns from the dataframe\n",
    "            df = mini_expand5(pair=coin, i=loc_start, j=loc_end, window=WINDOW_SIZE, metadata=MetaData,\n",
    "                              BUY_PCT=TAKE_PROFIT, SELL_PCT=STOP_LOSS, buy_function=buy_alwase)\n",
    "            # Add the prediction note to the dataframe\n",
    "            df.pop(\"buy\")\n",
    "            dt = df.to_numpy(dtype=np.float32)\n",
    "            predictions_note = backtest_model.predict(dt)\n",
    "            df[\"time\"] = df.index.values\n",
    "            predictions_round = predictions_note.round()\n",
    "            df['note'] = predictions_note\n",
    "\n",
    "            # Filter the rows with positive predictions and create a dataframe with the signal\n",
    "            df_signal_coin = df[predictions_round == 1][['time', 'price', 'note']].reset_index(drop=True)\n",
    "            df_signal_coin['coin'] = coin\n",
    "\n",
    "            SIGNAL_DF = pd.concat([SIGNAL_DF, df_signal_coin])\n",
    "        except:\n",
    "            print(f\"error at {day} in {coin}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "coin=\"XRP/USDT\"\n",
    "day=pd.Timestamp(\"2023-02-10 00:00:00\")\n",
    "loc_start=df_list1m[coin].index.get_loc(day)\n",
    "loc_end=df_list1m[coin].index.get_loc(day+pd.Timedelta('1 day'))\n",
    "gc.collect()\n",
    "df=mini_expand4(pair=coin,i=loc_start,j=loc_end,window=WINDOW_SIZE,metadata=MetaData,BUY_PCT=TAKE_PROFIT,SELL_PCT=STOP_LOSS,buy_function=buy_alwase)\n",
    "df.pop(\"buy\")\n",
    "dt = df.to_numpy(dtype=np.float32)\n",
    "predictions_note = backtest_model.predict(dt)\n",
    "df[\"time\"] = df.index.values\n",
    "predictions_round = predictions_note.round()\n",
    "df['note'] = predictions_note\n",
    "\n",
    "# Filter the rows with positive predictions and create a dataframe with the signal\n",
    "df_signal_coin = df[predictions_round == 1][['time', 'price', 'note']].reset_index(drop=True)\n",
    "df_signal_coin['coin'] = coin\n",
    "\n",
    "SIGNAL_DF = pd.concat([SIGNAL_DF, df_signal_coin])\n",
    "# dt=df.iloc[:,:-1].to_numpy(dtype=np.float32)\n",
    "# predictions_note=backtest_model.predict(dt)\n",
    "# predictions_round=predictions_note.round()\n",
    "# dico_signal={\"coin\":coin,\"time\":df[predictions_round==1].index.values,\"price\":df[predictions_round==1][\"price\"].values,\"note\":predictions_note[predictions_round==1]}\n",
    "# df_signal_coin = pd.DataFrame(dico_signal)\n",
    "#SIGNAL_DF=pd.concat([SIGNAL_DF,df_signal_coin])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 69,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "def backtest_buy_sell(PORTFOLIO, ORDER_HISTORY, SIGNAL_DF, df_list1m, start_period, end_period):\n",
    "    # Define some constants\n",
    "    BUY_SIDE = 'BUY'\n",
    "    SELL_SIDE = 'SELL'\n",
    "    EXECUTED_STATUS = 'EXECUTED'\n",
    "    CANCELLED_STATUS = 'CANCELLED'\n",
    "\n",
    "    # Loop through all the rows in the signal dataframe\n",
    "    for index, row in SIGNAL_DF.iterrows():\n",
    "        coin = row['coin']\n",
    "        time = row['time']\n",
    "        price = row['price'] # We assume there's only one price per signal\n",
    "        note = row['note'] # We assume there's only one note per signal\n",
    "\n",
    "        # Check if the coin is already in the PORTFOLIO\n",
    "        slot_num = is_coin_in_portfolio(coin, time)\n",
    "        if slot_num:\n",
    "            # If the coin is already in the PORTFOLIO, update the existing slot\n",
    "            slot_symbol = f'slot{slot_num}_symbol'\n",
    "            slot_volume = f'slot{slot_num}_volume'\n",
    "            slot_original_price_usdt = f'slot{slot_num}_original_price_USDT'\n",
    "            slot_current_total_usdt = f'slot{slot_num}_current_total_USDT'\n",
    "\n",
    "            # Calculate the new volume and bought USDT based on the current price\n",
    "            current_total_usdt = PORTFOLIO['total_USDT'].iloc[-1]\n",
    "            new_volume = (PORTFOLIO[slot_original_price_usdt].iloc[-1] * (1 - TRADING_FEE)) / price\n",
    "            new_original_price_usdt = new_volume * price\n",
    "\n",
    "            # Update the PORTFOLIO dataframe\n",
    "            PORTFOLIO.at[time, slot_volume] = new_volume\n",
    "            PORTFOLIO.at[time, slot_original_price_usdt] = new_original_price_usdt\n",
    "            PORTFOLIO.at[time, slot_current_total_usdt] = new_original_price_usdt + (current_total_usdt - PORTFOLIO[slot_original_price_usdt].iloc[-1])\n",
    "\n",
    "            # Add an order to the order history dataframe\n",
    "            order_id = len(ORDER_HISTORY) + 1\n",
    "            order_side = SELL_SIDE if note < 0 else BUY_SIDE\n",
    "            order_executed = abs(note)\n",
    "            order_quantity = new_volume\n",
    "            order_status = EXECUTED_STATUS\n",
    "            order_price = price\n",
    "            order_time = time\n",
    "            order_pair = f'{coin}/{PAIR_WITH}'\n",
    "\n",
    "            ORDER_HISTORY = ORDER_HISTORY.append({'Order ID': order_id, 'Pair': order_pair, 'Side': order_side,\n",
    "                                                  'Price': order_price, 'Quantity': order_quantity,\n",
    "                                                  'Executed': order_executed, 'Time': order_time,\n",
    "                                                  'Status': order_status}, ignore_index=True)\n",
    "        else:\n",
    "            # If the coin is not in the PORTFOLIO, find the first empty slot\n",
    "            for i in range(1, TRADE_SLOTS + 1):\n",
    "                if pd.isna(PORTFOLIO[f'slot{i}_symbol'].iloc[-1]):\n",
    "                    # Calculate the volume and bought USDT based on the current price\n",
    "                    volume = (MAX_TRADE_PER_SLOTE * (1 - TRADING_FEE)) / price\n",
    "                    bought_usdt = volume * price\n",
    "\n",
    "                    # Update the PORTFOLIO dataframe\n",
    "                    PORTFOLIO.at[time, f'slot{i}_symbol'] = coin\n",
    "                    PORTFOLIO.at[time, f'slot{i}_volume'] = volume\n",
    "                    PORTFOLIO.at[time, f'slot{i}_original_price_USDT'] = bought_usdt\n",
    "                    PORTFOLIO.at[time, f'slot{i}_current_total_USDT'] = bought_usdt + PORTFOLIO['total_USDT'].iloc[-1]\n",
    "                # Add an order to the order history dataframe\n",
    "                order_id = len(ORDER_HISTORY) + 1\n",
    "                order_side = BUY_SIDE\n",
    "                order_executed = abs(note)\n",
    "                order_quantity = volume\n",
    "                order_status = EXECUTED_STATUS\n",
    "                order_price = price\n",
    "                order_time = time\n",
    "                order_pair = f'{coin}/{PAIR_WITH}'\n",
    "\n",
    "                ORDER_HISTORY = ORDER_HISTORY.append({'Order ID': order_id, 'Pair': order_pair, 'Side': order_side,\n",
    "                                                        'Price': order_price, 'Quantity': order_quantity,\n",
    "                                                        'Executed': order_executed, 'Time': order_time,\n",
    "                                                        'Status': order_status}, ignore_index=True)\n",
    "\n",
    "                break\n",
    "\n",
    "    return PORTFOLIO, ORDER_HISTORY\n",
    "                    \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 70,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Index(['reserve_USDT', 'total_USDT', 'slot1_symbol', 'slot1_volume',\n",
       "       'slot1_original_price_USDT', 'slot1_current_total_USDT', 'slot2_symbol',\n",
       "       'slot2_volume', 'slot2_original_price_USDT', 'slot2_current_total_USDT',\n",
       "       'slot3_symbol', 'slot3_volume', 'slot3_original_price_USDT',\n",
       "       'slot3_current_total_USDT', 'slot4_symbol', 'slot4_volume',\n",
       "       'slot4_original_price_USDT', 'slot4_current_total_USDT', 'slot5_symbol',\n",
       "       'slot5_volume', 'slot5_original_price_USDT',\n",
       "       'slot5_current_total_USDT'],\n",
       "      dtype='object')"
      ]
     },
     "execution_count": 70,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "PORTFOLIO.columns"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "is_coin_in_portfolio(coin, pd.Timestamp() )"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The code is a backtesting strategy to simulate buying and selling cryptocurrencies using a given signal DataFrame and historical prices of the cryptocurrencies.\n",
    "\n",
    "The PORTFOLIO DataFrame is used to keep track of the state of the PORTFOLIO at each point in time during the backtesting. It contains information about the reserved and total amounts of the base currency (USDT), as well as the symbols, volumes, original prices, and current total values of up to 5 cryptocurrencies held in slots.\n",
    "\n",
    "The fisrt_empty_slot() function checks if there is an empty slot in the PORTFOLIO where a new cryptocurrency can be added. If there is an empty slot, it returns the slot number. Otherwise, it returns False.\n",
    "\n",
    "The buy_coin() function simulates buying a cryptocurrency at a given time and price. It checks if the cryptocurrency is not already in the PORTFOLIO and if there is enough reserved base currency to buy it. If the conditions are met, it updates the PORTFOLIO DataFrame by subtracting the base currency used for buying and adding the bought cryptocurrency to an empty slot. It also prints a message indicating the amount and symbol of the bought cryptocurrency. Otherwise, it prints a message indicating that the buying cannot be performed.\n",
    "\n",
    "The upadate_slots() function updates the PORTFOLIO DataFrame for the current time by computing the current values of all the cryptocurrencies held in the slots using the historical prices of the cryptocurrencies. It then updates the slot information in the PORTFOLIO DataFrame.\n",
    "\n",
    "The stop_loss_or_take_profit() function is not implemented in the provided code.\n",
    "\n",
    "The backtest_buy_sell() function is the main function that performs the backtesting. It initializes the PORTFOLIO and ORDER_HISTORY DataFrames, defines some constants, and loops over the time range specified by the start_period and end_period parameters. At each time step, it checks the signal DataFrame for a buying or selling signal, and if there is a buying signal, it calls the buy_coin() function. If there is a selling signal, it calls the stop_loss_or_take_profit() function (not implemented) to check if the stop-loss or take-profit conditions are met, and if they are, it simulates selling the cryptocurrency by calling the sell_coin() function (not implemented). It then updates the PORTFOLIO and ORDER_HISTORY DataFrames for the current time step by calling the upadate_slots() function. Finally, it checks if the maximum holding time for each slot has been exceeded, and if it has, it simulates selling the cryptocurrency in that slot by calling the sell_coin() function (not implemented). The function returns the PORTFOLIO and ORDER_HISTORY DataFrames at the end of the backtesting."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 82,
   "metadata": {},
   "outputs": [],
   "source": [
    "def fisrt_empty_slot(time,PORTFOLIO=PORTFOLIO):\n",
    "    for i in range(1,TRADE_SLOTS+1):\n",
    "        if pd.isna(PORTFOLIO[f'slot{i}_symbol'].iloc[-1]):\n",
    "            return i\n",
    "    return False\n",
    "\n",
    "def buy_coin(time,coin,price,PORTFOLIO=PORTFOLIO,pair_whith_qte=TRADE_TOTAL):\n",
    "    previous_minute=time-pd.Timedelta(\"1 minute\")\n",
    "    slot_num = is_coin_in_portfolio(coin, previous_minute, PORTFOLIO)\n",
    "    previous_reserve=PORTFOLIO.loc[previous_minute,f'reserve_{PAIR_WITH}']\n",
    "    slot_ft=fisrt_empty_slot(previous_minute,PORTFOLIO)\n",
    "    if (slot_num==False) and (previous_reserve >= pair_whith_qte ) :\n",
    "        PORTFOLIO.at[time,f'reserve_{PAIR_WITH}']=previous_reserve-previous_reserve\n",
    "        PORTFOLIO.at[time,f'total_{PAIR_WITH}']=PORTFOLIO.at[previous_minute,f'total_{PAIR_WITH}']-TRADING_FEE*pair_whith_qte/100\n",
    "        PORTFOLIO.at[time,f'slot{slot_ft}_symbol']=coin\n",
    "        PORTFOLIO.at[time,f'slot{slot_ft}_volume']=price*(pair_whith_qte-(TRADING_FEE*pair_whith_qte/100))\n",
    "        PORTFOLIO.at[time, f'slot{slot_ft}_original_price_{PAIR_WITH}']=price\n",
    "        PORTFOLIO.at[time, f'slot{slot_ft}_current_total_{PAIR_WITH}']=price*PORTFOLIO.at[time,f'slot{slot_ft}_volume']\n",
    "        print(f\"good condition for buying {PORTFOLIO.at[time,f'slot{slot_ft}_volume']} x {coin} at {price} \")\n",
    "    else:\n",
    "        print('xxx we cannot buy  {coin} at {price}  in {time} xxx')\n",
    "    return PORTFOLIO\n",
    "\n",
    "def upadate_slots(time,df_list1m,PORTFOLIO=PORTFOLIO):\n",
    "    previous_minute=time-pd.Timedelta(\"1 minute\")\n",
    "    previous_reserve=PORTFOLIO.at[previous_minute,f'reserve_{PAIR_WITH}']\n",
    "    PORTFOLIO.at[time,f'reserve_{PAIR_WITH}']=previous_reserve\n",
    "    previous_total=PORTFOLIO.at[previous_minute,f'total_{PAIR_WITH}']\n",
    "    for slot_ft in range(1,TRADE_SLOTS+1):\n",
    "        if not pd.isna(PORTFOLIO.at[previous_minute,f'slot{slot_ft}_symbol']):\n",
    "            #get previous data\n",
    "            coin=PORTFOLIO.at[previous_minute,f'slot{slot_ft}_symbol']\n",
    "            bought_at=PORTFOLIO.at[previous_minute, f'slot{slot_ft}_original_price_{PAIR_WITH}']\n",
    "            previous_total_slot_value=PORTFOLIO.at[previous_minute, f'slot{slot_ft}_current_total_{PAIR_WITH}']\n",
    "            slot_volume=PORTFOLIO.at[previous_minute,f'slot{slot_ft}_volume']\n",
    "            #Computation \n",
    "            new_total_slot_value=df_list1m[coin].at[\"\",\"close\"]*slot_volume\n",
    "            slot_value_difference=new_total_slot_value-previous_total_slot_value\n",
    "            new_total_assets_value=previous_total+slot_value_difference\n",
    "            #update the slot using new price form df_list1m dataset\n",
    "            PORTFOLIO.at[time,f'slot{slot_ft}_symbol']=coin\n",
    "            PORTFOLIO.at[time, f'slot{slot_ft}_original_price_{PAIR_WITH}']=bought_at\n",
    "            PORTFOLIO.at[time,f'slot{slot_ft}_volume']=slot_volume\n",
    "            PORTFOLIO.at[time, f'slot{slot_ft}_current_total_{PAIR_WITH}']=new_total_slot_value\n",
    "            PORTFOLIO.at[time,f'total_{PAIR_WITH}']=new_total_assets_value           \n",
    "    return PORTFOLIO\n",
    "  \n",
    "def stop_loss_or_take_profit(time, df_list1m, PORTFOLIO, st_pct, tp_pct, trade_fee):\n",
    "    for slot_ft in range(1, TRADE_SLOTS+1):\n",
    "        coin=PORTFOLIO.at[time, f\"slot{slot_ft}_symbol\"]\n",
    "        if PORTFOLIO.at[time, f\"slot{slot_ft}_symbol\"] == coin:\n",
    "            # Check if stop loss or take profit order should be triggered\n",
    "            bought_price = PORTFOLIO.at[time, f\"slot{slot_ft}_original_price_{PAIR_WITH}\"]\n",
    "            slot_volume = PORTFOLIO.at[time, f\"slot{slot_ft}_volume\"]\n",
    "            current_price= df_list1m[coin].at(time,\"close\")\n",
    "            slot_total_value = current_price * slot_volume\n",
    "            slot_current_profit = ((current_price - bought_price) * slot_volume) - (trade_fee/100 * slot_total_value)\n",
    "            slot_current_profit_pct = (slot_current_profit / (bought_price * slot_volume)) * 100\n",
    "\n",
    "            if slot_current_profit_pct < st_pct:\n",
    "                # Trigger stop loss\n",
    "                PORTFOLIO.at[time, f\"slot{slot_ft}_symbol\"] = np.nan\n",
    "                PORTFOLIO.at[time, f\"slot{slot_ft}_volume\"] = np.nan\n",
    "                PORTFOLIO.at[time, f\"slot{slot_ft}_original_price_{PAIR_WITH}\"] = np.nan\n",
    "                PORTFOLIO.at[time, f\"slot{slot_ft}_current_total_{PAIR_WITH}\"] = np.nan\n",
    "                PORTFOLIO.at[time, \"reserve_USDT\"] += slot_total_value\n",
    "                print(f\"Stop loss triggered for {coin} in slot {slot_ft}\")\n",
    "             #   return PORTFOLIO\n",
    "\n",
    "            elif slot_current_profit_pct > tp_pct:\n",
    "                # Trigger take profit\n",
    "                PORTFOLIO.at[time, f\"slot{slot_ft}_symbol\"] = np.nan\n",
    "                PORTFOLIO.at[time, f\"slot{slot_ft}_volume\"] = np.nan\n",
    "                PORTFOLIO.at[time, f\"slot{slot_ft}_original_price_{PAIR_WITH}\"] = np.nan\n",
    "                PORTFOLIO.at[time, f\"slot{slot_ft}_current_total_{PAIR_WITH}\"] = np.nan\n",
    "                PORTFOLIO.at[time, \"reserve_USDT\"] += slot_total_value\n",
    "                PORTFOLIO.at[time, \"total_USDT\"] += (slot_total_value + (slot_current_profit_pct/100 * bought_price * slot_volume))\n",
    "                print(f\"Take profit triggered for {coin} in slot {slot_ft}\")\n",
    "                #return PORTFOLIO\n",
    "            \n",
    "    return PORTFOLIO\n",
    "\n",
    "    \n",
    "        \n",
    "def backtest_buy_sell(SIGNAL_DF, df_list1m, start_period, end_period):\n",
    "    # Define some constants\n",
    "    BUY_SIDE = 'BUY'\n",
    "    SELL_SIDE = 'SELL'\n",
    "    EXECUTED_STATUS = 'EXECUTED'\n",
    "    CANCELLED_STATUS = 'CANCELLED'\n",
    "    #initialize vaiable and counters\n",
    "    curent_time=pd.Timestamp(start_period)\n",
    "    end_period_marge=end_period+pd.Timedelta(f\"{2*MAX_HOLDING_TIME} minute\")\n",
    "    PORTFOLIO=create_portfolio_dataframe(TRADE_SLOTS,init_quantity=500, base_currency=PAIR_WITH) #pair with plus slots plus total\n",
    "    ORDER_HISTORY= pd.DataFrame(columns= ['Order ID', 'Pair', 'Side', 'Price', 'Quantity', 'Executed', 'Time', 'Status'])\n",
    "    PreiodRange = pd.date_range(start=pd.Timestamp(start_period), end=pd.Timestamp(end_period), freq='1min')\n",
    "    # Verifie buying oportunities\n",
    "    for curent_time in PreiodRange:\n",
    "        previous_minute=curent_time-pd.Timedelta(\"1 minute\")\n",
    "        previous_reserve=PORTFOLIO.loc[previous_minute,f'reserve_{PAIR_WITH}']\n",
    "        upadate_slots(curent_time,df_list1m,PORTFOLIO=PORTFOLIO)\n",
    "        print(curent_time)\n",
    "        for i,sig_row in SIGNAL_DF[SIGNAL_DF.time==pd.Timestamp(curent_time)].iterrows():\n",
    "            # buy the coin if solt and cash is avalible:\n",
    "            coin = sig_row['coin']\n",
    "            time = sig_row['time']\n",
    "            price = sig_row['price'] # We assume there's only one price per signal\n",
    "            note = sig_row['note'] \n",
    "            slot_num = is_coin_in_portfolio(coin, previous_minute, PORTFOLIO)\n",
    "            # buy first:\n",
    "            if (note + PRESSISION) >= 0.5:\n",
    "                PORTFOLIO=buy_coin(time,coin,price,PORTFOLIO=PORTFOLIO,pair_whith_qte=TRADE_TOTAL)\n",
    "        \n",
    "        PORTFOLIO=stop_loss_or_take_profit(curent_time, df_list1m, PORTFOLIO, STOP_LOSS , TAKE_PROFIT, TRADING_FEE )\n",
    "        \n",
    "        ptc_benifit=100*PORTFOLIO.at[curent_time,f'total_{PAIR_WITH}']/PORTFOLIO[f'total_{PAIR_WITH}'].iloc[0]\n",
    "        print(f\"total benifit ptc {ptc_benifit}\")       \n",
    "    return PORTFOLIO     \n",
    "                \n",
    "                \n",
    "            \n",
    "        \n",
    "            "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "for i,row in SIGNAL_DF[SIGNAL_DF.time==pd.Timestamp(\"2023-02-10 23:59:00\")].iterrows():\n",
    "            # buy the coin if solt and cash is avalible:\n",
    "            coin = row['coin']\n",
    "            time = row['time']\n",
    "            price = row['price'] # We assume there's only one price per signal\n",
    "            note = row['note'] \n",
    "            print(price)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "backtest_buy_sell(SIGNAL_DF, df_list1m, start_period, end_period)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 83,
   "metadata": {},
   "outputs": [
    {
     "ename": "KeyError",
     "evalue": "Timestamp('2022-04-20 23:59:00', freq='T')",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mKeyError\u001b[0m                                  Traceback (most recent call last)",
      "File \u001b[0;32m/usr/local/lib/python3.9/dist-packages/pandas/_libs/index.pyx:548\u001b[0m, in \u001b[0;36mpandas._libs.index.DatetimeEngine.get_loc\u001b[0;34m()\u001b[0m\n",
      "File \u001b[0;32mpandas/_libs/hashtable_class_helper.pxi:2263\u001b[0m, in \u001b[0;36mpandas._libs.hashtable.Int64HashTable.get_item\u001b[0;34m()\u001b[0m\n",
      "File \u001b[0;32mpandas/_libs/hashtable_class_helper.pxi:2273\u001b[0m, in \u001b[0;36mpandas._libs.hashtable.Int64HashTable.get_item\u001b[0;34m()\u001b[0m\n",
      "\u001b[0;31mKeyError\u001b[0m: 1650499140000000000",
      "\nDuring handling of the above exception, another exception occurred:\n",
      "\u001b[0;31mKeyError\u001b[0m                                  Traceback (most recent call last)",
      "File \u001b[0;32m/usr/local/lib/python3.9/dist-packages/pandas/core/indexes/base.py:3803\u001b[0m, in \u001b[0;36mIndex.get_loc\u001b[0;34m(self, key, method, tolerance)\u001b[0m\n\u001b[1;32m   3802\u001b[0m \u001b[39mtry\u001b[39;00m:\n\u001b[0;32m-> 3803\u001b[0m     \u001b[39mreturn\u001b[39;00m \u001b[39mself\u001b[39;49m\u001b[39m.\u001b[39;49m_engine\u001b[39m.\u001b[39;49mget_loc(casted_key)\n\u001b[1;32m   3804\u001b[0m \u001b[39mexcept\u001b[39;00m \u001b[39mKeyError\u001b[39;00m \u001b[39mas\u001b[39;00m err:\n",
      "File \u001b[0;32m/usr/local/lib/python3.9/dist-packages/pandas/_libs/index.pyx:516\u001b[0m, in \u001b[0;36mpandas._libs.index.DatetimeEngine.get_loc\u001b[0;34m()\u001b[0m\n",
      "File \u001b[0;32m/usr/local/lib/python3.9/dist-packages/pandas/_libs/index.pyx:550\u001b[0m, in \u001b[0;36mpandas._libs.index.DatetimeEngine.get_loc\u001b[0;34m()\u001b[0m\n",
      "\u001b[0;31mKeyError\u001b[0m: Timestamp('2022-04-20 23:59:00', freq='T')",
      "\nThe above exception was the direct cause of the following exception:\n",
      "\u001b[0;31mKeyError\u001b[0m                                  Traceback (most recent call last)",
      "File \u001b[0;32m/usr/local/lib/python3.9/dist-packages/pandas/core/indexes/datetimes.py:736\u001b[0m, in \u001b[0;36mDatetimeIndex.get_loc\u001b[0;34m(self, key, method, tolerance)\u001b[0m\n\u001b[1;32m    735\u001b[0m \u001b[39mtry\u001b[39;00m:\n\u001b[0;32m--> 736\u001b[0m     \u001b[39mreturn\u001b[39;00m Index\u001b[39m.\u001b[39;49mget_loc(\u001b[39mself\u001b[39;49m, key, method, tolerance)\n\u001b[1;32m    737\u001b[0m \u001b[39mexcept\u001b[39;00m \u001b[39mKeyError\u001b[39;00m \u001b[39mas\u001b[39;00m err:\n",
      "File \u001b[0;32m/usr/local/lib/python3.9/dist-packages/pandas/core/indexes/base.py:3805\u001b[0m, in \u001b[0;36mIndex.get_loc\u001b[0;34m(self, key, method, tolerance)\u001b[0m\n\u001b[1;32m   3804\u001b[0m \u001b[39mexcept\u001b[39;00m \u001b[39mKeyError\u001b[39;00m \u001b[39mas\u001b[39;00m err:\n\u001b[0;32m-> 3805\u001b[0m     \u001b[39mraise\u001b[39;00m \u001b[39mKeyError\u001b[39;00m(key) \u001b[39mfrom\u001b[39;00m \u001b[39merr\u001b[39;00m\n\u001b[1;32m   3806\u001b[0m \u001b[39mexcept\u001b[39;00m \u001b[39mTypeError\u001b[39;00m:\n\u001b[1;32m   3807\u001b[0m     \u001b[39m# If we have a listlike key, _check_indexing_error will raise\u001b[39;00m\n\u001b[1;32m   3808\u001b[0m     \u001b[39m#  InvalidIndexError. Otherwise we fall through and re-raise\u001b[39;00m\n\u001b[1;32m   3809\u001b[0m     \u001b[39m#  the TypeError.\u001b[39;00m\n",
      "\u001b[0;31mKeyError\u001b[0m: Timestamp('2022-04-20 23:59:00', freq='T')",
      "\nThe above exception was the direct cause of the following exception:\n",
      "\u001b[0;31mKeyError\u001b[0m                                  Traceback (most recent call last)",
      "Cell \u001b[0;32mIn [83], line 2\u001b[0m\n\u001b[1;32m      1\u001b[0m MAX_TRADE_PER_SLOTE\u001b[39m=\u001b[39m\u001b[39m100\u001b[39m\n\u001b[0;32m----> 2\u001b[0m PORTFOLIO\u001b[39m=\u001b[39mbacktest_buy_sell(SIGNAL_DF, df_list1m, start_period, end_period)\n",
      "Cell \u001b[0;32mIn [82], line 100\u001b[0m, in \u001b[0;36mbacktest_buy_sell\u001b[0;34m(SIGNAL_DF, df_list1m, start_period, end_period)\u001b[0m\n\u001b[1;32m     98\u001b[0m \u001b[39mfor\u001b[39;00m curent_time \u001b[39min\u001b[39;00m PreiodRange:\n\u001b[1;32m     99\u001b[0m     previous_minute\u001b[39m=\u001b[39mcurent_time\u001b[39m-\u001b[39mpd\u001b[39m.\u001b[39mTimedelta(\u001b[39m\"\u001b[39m\u001b[39m1 minute\u001b[39m\u001b[39m\"\u001b[39m)\n\u001b[0;32m--> 100\u001b[0m     previous_reserve\u001b[39m=\u001b[39mPORTFOLIO\u001b[39m.\u001b[39;49mloc[previous_minute,\u001b[39mf\u001b[39;49m\u001b[39m'\u001b[39;49m\u001b[39mreserve_\u001b[39;49m\u001b[39m{\u001b[39;49;00mPAIR_WITH\u001b[39m}\u001b[39;49;00m\u001b[39m'\u001b[39;49m]\n\u001b[1;32m    101\u001b[0m     upadate_slots(curent_time,df_list1m,PORTFOLIO\u001b[39m=\u001b[39mPORTFOLIO)\n\u001b[1;32m    102\u001b[0m     \u001b[39mprint\u001b[39m(curent_time)\n",
      "File \u001b[0;32m/usr/local/lib/python3.9/dist-packages/pandas/core/indexing.py:1066\u001b[0m, in \u001b[0;36m_LocationIndexer.__getitem__\u001b[0;34m(self, key)\u001b[0m\n\u001b[1;32m   1064\u001b[0m     key \u001b[39m=\u001b[39m \u001b[39mtuple\u001b[39m(com\u001b[39m.\u001b[39mapply_if_callable(x, \u001b[39mself\u001b[39m\u001b[39m.\u001b[39mobj) \u001b[39mfor\u001b[39;00m x \u001b[39min\u001b[39;00m key)\n\u001b[1;32m   1065\u001b[0m     \u001b[39mif\u001b[39;00m \u001b[39mself\u001b[39m\u001b[39m.\u001b[39m_is_scalar_access(key):\n\u001b[0;32m-> 1066\u001b[0m         \u001b[39mreturn\u001b[39;00m \u001b[39mself\u001b[39;49m\u001b[39m.\u001b[39;49mobj\u001b[39m.\u001b[39;49m_get_value(\u001b[39m*\u001b[39;49mkey, takeable\u001b[39m=\u001b[39;49m\u001b[39mself\u001b[39;49m\u001b[39m.\u001b[39;49m_takeable)\n\u001b[1;32m   1067\u001b[0m     \u001b[39mreturn\u001b[39;00m \u001b[39mself\u001b[39m\u001b[39m.\u001b[39m_getitem_tuple(key)\n\u001b[1;32m   1068\u001b[0m \u001b[39melse\u001b[39;00m:\n\u001b[1;32m   1069\u001b[0m     \u001b[39m# we by definition only have the 0th axis\u001b[39;00m\n",
      "File \u001b[0;32m/usr/local/lib/python3.9/dist-packages/pandas/core/frame.py:3921\u001b[0m, in \u001b[0;36mDataFrame._get_value\u001b[0;34m(self, index, col, takeable)\u001b[0m\n\u001b[1;32m   3915\u001b[0m engine \u001b[39m=\u001b[39m \u001b[39mself\u001b[39m\u001b[39m.\u001b[39mindex\u001b[39m.\u001b[39m_engine\n\u001b[1;32m   3917\u001b[0m \u001b[39mif\u001b[39;00m \u001b[39mnot\u001b[39;00m \u001b[39misinstance\u001b[39m(\u001b[39mself\u001b[39m\u001b[39m.\u001b[39mindex, MultiIndex):\n\u001b[1;32m   3918\u001b[0m     \u001b[39m# CategoricalIndex: Trying to use the engine fastpath may give incorrect\u001b[39;00m\n\u001b[1;32m   3919\u001b[0m     \u001b[39m#  results if our categories are integers that dont match our codes\u001b[39;00m\n\u001b[1;32m   3920\u001b[0m     \u001b[39m# IntervalIndex: IntervalTree has no get_loc\u001b[39;00m\n\u001b[0;32m-> 3921\u001b[0m     row \u001b[39m=\u001b[39m \u001b[39mself\u001b[39;49m\u001b[39m.\u001b[39;49mindex\u001b[39m.\u001b[39;49mget_loc(index)\n\u001b[1;32m   3922\u001b[0m     \u001b[39mreturn\u001b[39;00m series\u001b[39m.\u001b[39m_values[row]\n\u001b[1;32m   3924\u001b[0m \u001b[39m# For MultiIndex going through engine effectively restricts us to\u001b[39;00m\n\u001b[1;32m   3925\u001b[0m \u001b[39m#  same-length tuples; see test_get_set_value_no_partial_indexing\u001b[39;00m\n",
      "File \u001b[0;32m/usr/local/lib/python3.9/dist-packages/pandas/core/indexes/datetimes.py:738\u001b[0m, in \u001b[0;36mDatetimeIndex.get_loc\u001b[0;34m(self, key, method, tolerance)\u001b[0m\n\u001b[1;32m    736\u001b[0m     \u001b[39mreturn\u001b[39;00m Index\u001b[39m.\u001b[39mget_loc(\u001b[39mself\u001b[39m, key, method, tolerance)\n\u001b[1;32m    737\u001b[0m \u001b[39mexcept\u001b[39;00m \u001b[39mKeyError\u001b[39;00m \u001b[39mas\u001b[39;00m err:\n\u001b[0;32m--> 738\u001b[0m     \u001b[39mraise\u001b[39;00m \u001b[39mKeyError\u001b[39;00m(orig_key) \u001b[39mfrom\u001b[39;00m \u001b[39merr\u001b[39;00m\n",
      "\u001b[0;31mKeyError\u001b[0m: Timestamp('2022-04-20 23:59:00', freq='T')"
     ]
    }
   ],
   "source": [
    "MAX_TRADE_PER_SLOTE=100\n",
    "PORTFOLIO=backtest_buy_sell(SIGNAL_DF, df_list1m, start_period, end_period)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 84,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>reserve_USDT</th>\n",
       "      <th>total_USDT</th>\n",
       "      <th>slot1_symbol</th>\n",
       "      <th>slot1_volume</th>\n",
       "      <th>slot1_original_price_USDT</th>\n",
       "      <th>slot1_current_total_USDT</th>\n",
       "      <th>slot2_symbol</th>\n",
       "      <th>slot2_volume</th>\n",
       "      <th>slot2_original_price_USDT</th>\n",
       "      <th>slot2_current_total_USDT</th>\n",
       "      <th>...</th>\n",
       "      <th>slot3_original_price_USDT</th>\n",
       "      <th>slot3_current_total_USDT</th>\n",
       "      <th>slot4_symbol</th>\n",
       "      <th>slot4_volume</th>\n",
       "      <th>slot4_original_price_USDT</th>\n",
       "      <th>slot4_current_total_USDT</th>\n",
       "      <th>slot5_symbol</th>\n",
       "      <th>slot5_volume</th>\n",
       "      <th>slot5_original_price_USDT</th>\n",
       "      <th>slot5_current_total_USDT</th>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>date</th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "      <th></th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>2022-04-21</th>\n",
       "      <td>500.0</td>\n",
       "      <td>500</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>...</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "<p>1 rows × 22 columns</p>\n",
       "</div>"
      ],
      "text/plain": [
       "            reserve_USDT total_USDT slot1_symbol slot1_volume  \\\n",
       "date                                                            \n",
       "2022-04-21         500.0        500          NaN          NaN   \n",
       "\n",
       "           slot1_original_price_USDT slot1_current_total_USDT slot2_symbol  \\\n",
       "date                                                                         \n",
       "2022-04-21                       NaN                      NaN          NaN   \n",
       "\n",
       "           slot2_volume slot2_original_price_USDT slot2_current_total_USDT  \\\n",
       "date                                                                         \n",
       "2022-04-21          NaN                       NaN                      NaN   \n",
       "\n",
       "            ... slot3_original_price_USDT slot3_current_total_USDT  \\\n",
       "date        ...                                                      \n",
       "2022-04-21  ...                       NaN                      NaN   \n",
       "\n",
       "           slot4_symbol slot4_volume slot4_original_price_USDT  \\\n",
       "date                                                             \n",
       "2022-04-21          NaN          NaN                       NaN   \n",
       "\n",
       "           slot4_current_total_USDT slot5_symbol slot5_volume  \\\n",
       "date                                                            \n",
       "2022-04-21                      NaN          NaN          NaN   \n",
       "\n",
       "           slot5_original_price_USDT slot5_current_total_USDT  \n",
       "date                                                           \n",
       "2022-04-21                       NaN                      NaN  \n",
       "\n",
       "[1 rows x 22 columns]"
      ]
     },
     "execution_count": 84,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "PORTFOLIO"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 75,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>coin</th>\n",
       "      <th>time</th>\n",
       "      <th>price</th>\n",
       "      <th>note</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>LUNA/USDT</td>\n",
       "      <td>2022-05-09 00:10:00</td>\n",
       "      <td>64.197500</td>\n",
       "      <td>0.733129</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>GMT/USDT</td>\n",
       "      <td>2022-05-09 00:10:00</td>\n",
       "      <td>2.701777</td>\n",
       "      <td>0.820488</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>TRX/USDT</td>\n",
       "      <td>2022-05-09 00:10:00</td>\n",
       "      <td>0.087122</td>\n",
       "      <td>0.859069</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>APE/USDT</td>\n",
       "      <td>2022-05-09 00:10:00</td>\n",
       "      <td>11.347950</td>\n",
       "      <td>0.696792</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>SOL/USDT</td>\n",
       "      <td>2022-05-09 00:10:00</td>\n",
       "      <td>75.562500</td>\n",
       "      <td>0.500650</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>NEAR/USDT</td>\n",
       "      <td>2022-05-09 00:10:00</td>\n",
       "      <td>11.148500</td>\n",
       "      <td>0.793626</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>ADA/USDT</td>\n",
       "      <td>2022-05-09 00:10:00</td>\n",
       "      <td>0.742350</td>\n",
       "      <td>0.545682</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>AVAX/USDT</td>\n",
       "      <td>2022-05-09 00:10:00</td>\n",
       "      <td>52.047500</td>\n",
       "      <td>0.585509</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>WAVES/USDT</td>\n",
       "      <td>2022-05-09 00:10:00</td>\n",
       "      <td>12.967500</td>\n",
       "      <td>0.620075</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>ZIL/USDT</td>\n",
       "      <td>2022-05-09 00:10:00</td>\n",
       "      <td>0.077115</td>\n",
       "      <td>0.775240</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>AXS/USDT</td>\n",
       "      <td>2022-05-09 00:10:00</td>\n",
       "      <td>30.662500</td>\n",
       "      <td>0.853654</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>ALGO/USDT</td>\n",
       "      <td>2022-05-09 00:10:00</td>\n",
       "      <td>0.736050</td>\n",
       "      <td>0.750318</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "         coin                time      price      note\n",
       "3   LUNA/USDT 2022-05-09 00:10:00  64.197500  0.733129\n",
       "3    GMT/USDT 2022-05-09 00:10:00   2.701777  0.820488\n",
       "3    TRX/USDT 2022-05-09 00:10:00   0.087122  0.859069\n",
       "3    APE/USDT 2022-05-09 00:10:00  11.347950  0.696792\n",
       "3    SOL/USDT 2022-05-09 00:10:00  75.562500  0.500650\n",
       "3   NEAR/USDT 2022-05-09 00:10:00  11.148500  0.793626\n",
       "3    ADA/USDT 2022-05-09 00:10:00   0.742350  0.545682\n",
       "3   AVAX/USDT 2022-05-09 00:10:00  52.047500  0.585509\n",
       "3  WAVES/USDT 2022-05-09 00:10:00  12.967500  0.620075\n",
       "3    ZIL/USDT 2022-05-09 00:10:00   0.077115  0.775240\n",
       "3    AXS/USDT 2022-05-09 00:10:00  30.662500  0.853654\n",
       "3   ALGO/USDT 2022-05-09 00:10:00   0.736050  0.750318"
      ]
     },
     "execution_count": 75,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "SIGNAL_DF[SIGNAL_DF.time==pd.Timestamp(\"2022-05-09 00:10:00\")]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 76,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "error :'2022-05-09 00:10:00'\n",
      "error :'2022-05-09 00:10:00'\n",
      "error :'2022-05-09 00:10:00'\n",
      "error :'2022-05-09 00:10:00'\n",
      "error :'2022-05-09 00:10:00'\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "False"
      ]
     },
     "execution_count": 76,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "is_coin_in_portfolio(symbol=\"LUNA/USDT\",instant=\"2022-05-09 00:10:00\",PORTFOLIO=PORTFOLIO)"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# --4 Initial Test"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.2"
  },
  "orig_nbformat": 4,
  "vscode": {
   "interpreter": {
    "hash": "e7370f93d1d0cde622a1f8e1c04877d8463912d04d973331ad4851f04de6915a"
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
